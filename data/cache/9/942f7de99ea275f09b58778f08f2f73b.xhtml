
<h1 class="sectionedit1" id="collections">Collections</h1>
<div class="level1">

<p>
<strong>Introduction</strong>
</p>

<p>
The Illuminate\Support\Collection class provides a fluent, convenient wrapper for working with arrays of data. For example, check out the following code. We&#039;ll use the collect helper to create a new collection instance from the array, run the strtoupper function on each element, and then remove all empty elements:
</p>
<pre class="code">$collection = collect([&#039;taylor&#039;, &#039;abigail&#039;, null])-&gt;map(function ($name) {
    return strtoupper($name);
})-&gt;reject(function ($name) {
    return empty($name);
});</pre>

<p>
As you can see, the Collection class allows you to chain its methods to perform fluent mapping and reducing of the underlying array. In general, collections are immutable, meaning every Collection method returns an entirely new Collection instance.
</p>

<p>
<strong>Creating Collections</strong>
</p>

<p>
As mentioned above, the collect helper returns a new Illuminate\Support\Collection instance for the given array. So, creating a collection is as simple as:
</p>
<pre class="code">$collection = collect([1, 2, 3]);</pre>

<p>
<strong>Extending Collections</strong>
</p>

<p>
Collections are «macroable», which allows you to add additional methods to the Collection class at run time. The Illuminate\Support\Collection class&#039; macro method accepts a closure that will be executed when your macro is called. The macro closure may access the collection&#039;s other methods via $this, just as if it were a real method of the collection class. For example, the following code adds a toUpper method to the Collection class:
</p>
<pre class="code">use Illuminate\Support\Collection;
use Illuminate\Support\Str;

Collection::macro(&#039;toUpper&#039;, function () {
    return $this-&gt;map(function ($value) {
        return Str::upper($value);
    });
});

$collection = collect([&#039;first&#039;, &#039;second&#039;]);

$upper = $collection-&gt;toUpper();

// [&#039;FIRST&#039;, &#039;SECOND&#039;]</pre>

<p>
Typically, you should declare collection macros in the boot method of a service provider.
</p>

<p>
<strong>Macro Arguments</strong>
</p>

<p>
If necessary, you may define macros that accept additional arguments:
</p>
<pre class="code">use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Lang;
use Illuminate\Support\Str;

Collection::macro(&#039;toLocale&#039;, function ($locale) {
    return $this-&gt;map(function ($value) use ($locale) {
        return Lang::get($value, $locale);
    });
});

$collection = collect([&#039;first&#039;, &#039;second&#039;]);

$translated = $collection-&gt;toLocale(&#039;es&#039;);</pre>

<p>
<strong>Available Methods</strong>
</p>

<p>
For the majority of the remaining collection documentation, we&#039;ll discuss each method available on the Collection class. Remember, all of these methods may be chained to fluently manipulate the underlying array. Furthermore, almost every method returns a new Collection instance, allowing you to preserve the original copy of the collection when necessary:
</p>

<p>
all
</p>

<p>
average
</p>

<p>
avg
</p>

<p>
chunk
</p>

<p>
chunkWhile
</p>

<p>
collapse
</p>

<p>
collect
</p>

<p>
combine
</p>

<p>
concat
</p>

<p>
contains
</p>

<p>
containsStrict
</p>

<p>
count
</p>

<p>
countBy
</p>

<p>
crossJoin
</p>

<p>
dd
</p>

<p>
diff
</p>

<p>
diffAssoc
</p>

<p>
diffKeys
</p>

<p>
dump
</p>

<p>
duplicates
</p>

<p>
duplicatesStrict
</p>

<p>
each
</p>

<p>
eachSpread
</p>

<p>
every
</p>

<p>
except
</p>

<p>
filter
</p>

<p>
first
</p>

<p>
firstWhere
</p>

<p>
flatMap
</p>

<p>
flatten
</p>

<p>
flip
</p>

<p>
forget
</p>

<p>
forPage
</p>

<p>
get
</p>

<p>
groupBy
</p>

<p>
has
</p>

<p>
implode
</p>

<p>
intersect
</p>

<p>
intersectByKeys
</p>

<p>
isEmpty
</p>

<p>
isNotEmpty
</p>

<p>
join
</p>

<p>
keyBy
</p>

<p>
keys
</p>

<p>
last
</p>

<p>
macro
</p>

<p>
make
</p>

<p>
map
</p>

<p>
mapInto
</p>

<p>
mapSpread
</p>

<p>
mapToGroups
</p>

<p>
mapWithKeys
</p>

<p>
max
</p>

<p>
median
</p>

<p>
merge
</p>

<p>
mergeRecursive
</p>

<p>
min
</p>

<p>
mode
</p>

<p>
nth
</p>

<p>
only
</p>

<p>
pad
</p>

<p>
partition
</p>

<p>
pipe
</p>

<p>
pipeInto
</p>

<p>
pluck
</p>

<p>
pop
</p>

<p>
prepend
</p>

<p>
pull
</p>

<p>
push
</p>

<p>
put
</p>

<p>
random
</p>

<p>
reduce
</p>

<p>
reject
</p>

<p>
replace
</p>

<p>
replaceRecursive
</p>

<p>
reverse
</p>

<p>
search
</p>

<p>
shift
</p>

<p>
shuffle
</p>

<p>
skip
</p>

<p>
skipUntil
</p>

<p>
skipWhile
</p>

<p>
slice
</p>

<p>
some
</p>

<p>
sort
</p>

<p>
sortBy
</p>

<p>
sortByDesc
</p>

<p>
sortDesc
</p>

<p>
sortKeys
</p>

<p>
sortKeysDesc
</p>

<p>
splice
</p>

<p>
split
</p>

<p>
splitIn
</p>

<p>
sum
</p>

<p>
take
</p>

<p>
takeUntil
</p>

<p>
takeWhile
</p>

<p>
tap
</p>

<p>
times
</p>

<p>
toArray
</p>

<p>
toJson
</p>

<p>
transform
</p>

<p>
union
</p>

<p>
unique
</p>

<p>
uniqueStrict
</p>

<p>
unless
</p>

<p>
unlessEmpty
</p>

<p>
unlessNotEmpty
</p>

<p>
unwrap
</p>

<p>
values
</p>

<p>
when
</p>

<p>
whenEmpty
</p>

<p>
whenNotEmpty
</p>

<p>
where
</p>

<p>
whereStrict
</p>

<p>
whereBetween
</p>

<p>
whereIn
</p>

<p>
whereInStrict
</p>

<p>
whereInstanceOf
</p>

<p>
whereNotBetween
</p>

<p>
whereNotIn
</p>

<p>
whereNotInStrict
</p>

<p>
whereNotNull
</p>

<p>
whereNull
</p>

<p>
wrap
</p>

<p>
zip
</p>

</div>
