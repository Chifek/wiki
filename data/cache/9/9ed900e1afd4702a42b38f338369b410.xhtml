
<h1 class="sectionedit1" id="solid">SOLID</h1>
<div class="level1">

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;SOLID&quot;,&quot;hid&quot;:&quot;solid&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:1,&quot;range&quot;:&quot;1-22&quot;} -->
<h2 class="sectionedit2" id="принцип_единственной_ответственности_single_responsibility_principle">Принцип единственной ответственности (Single Responsibility Principle)</h2>
<div class="level2">

<p>
<code>Существует лишь одна причина, приводящая к изменению класса.</code>
</p>

<p>
Один класс должен решать только какую-то одну задачу. Он может иметь несколько методов, но они должны использоваться лишь для решения общей задачи. Все методы и свойства должны служить одной цели. Если класс имеет несколько назначений, его нужно разделить на отдельные классы.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;\u041f\u0440\u0438\u043d\u0446\u0438\u043f \u0435\u0434\u0438\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0439 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438 (Single Responsibility Principle)&quot;,&quot;hid&quot;:&quot;\u043f\u0440\u0438\u043d\u0446\u0438\u043f_\u0435\u0434\u0438\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0439_\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0441\u0442\u0438_single_responsibility_principle&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:2,&quot;range&quot;:&quot;23-766&quot;} -->
<h2 class="sectionedit3" id="принцип_открытости_закрытости_open-closed_principle">Принцип открытости/закрытости (Open-closed Principle)</h2>
<div class="level2">

<p>
<code>Программные сущности должны быть открыты для расширения, но закрыты для модификации.</code>
</p>

<p>
Программные сущности (классы, модули, функции и прочее) должны быть расширяемыми без изменения своего содержимого. Если строго соблюдать этот принцип, то можно регулировать поведение кода без изменения самого исходника.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;\u041f\u0440\u0438\u043d\u0446\u0438\u043f \u043e\u0442\u043a\u0440\u044b\u0442\u043e\u0441\u0442\u0438\/\u0437\u0430\u043a\u0440\u044b\u0442\u043e\u0441\u0442\u0438 (Open-closed Principle)&quot;,&quot;hid&quot;:&quot;\u043f\u0440\u0438\u043d\u0446\u0438\u043f_\u043e\u0442\u043a\u0440\u044b\u0442\u043e\u0441\u0442\u0438_\u0437\u0430\u043a\u0440\u044b\u0442\u043e\u0441\u0442\u0438_open-closed_principle&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:3,&quot;range&quot;:&quot;767-1429&quot;} -->
<h2 class="sectionedit4" id="принцип_подстановки_барбары_лисков_liskov_substitution_principle">Принцип подстановки Барбары Лисков (Liskov Substitution Principle)</h2>
<div class="level2">

<p>
Этот принцип Барбара Лисков предложила в своём докладе “Data abstraction” в 1987-м. А в 1994-м идея была вкратце сформулирована Барбарой и Дженнет Уинг:
</p>

<p>
<code>Пусть φ(x) — доказуемое свойство объекта x типа T. Тогда φ(y) должно быть верным для объектов y типа S, где S — подтип T.</code>
</p>

<p>
В удобочитаемой версии повторяется практически всё, что говорил Бертранд Майер, но здесь в качестве базиса взята система типов:
</p>
<ol>
<li class="level1"><div class="li"> Предварительные условия не могут быть усилены в подтипе.</div>
</li>
<li class="level1"><div class="li"> Постусловия не могут быть ослаблены в подтипе.</div>
</li>
<li class="level1"><div class="li"> Инварианты супертипа могут быть сохранены в подтипе.</div>
</li>
</ol>

<p>
Роберт Мартин в 1996-м дал другое определение, более понятное:
</p>

<p>
<code>Функции, использующие указатели ссылок на базовые классы, должны уметь использовать объекты производных классов, даже не зная об этом.</code>
</p>

<p>
Попросту говоря: подкласс/производный класс должен быть взаимозаменяем с базовым/родительским классом.
</p>

<p>
Значит, любая реализация абстракции (интерфейса) должна быть взаимозаменяемой в любом месте, в котором принимается эта абстракция. По сути, когда мы используем в коде интерфейсы, то используем контракт не только по входным данным, принимаемым интерфейсом, но и по выходным данным, возвращаемым разными классами, реализующими этот интерфейс. В обоих случаях данные должны быть одного типа.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;\u041f\u0440\u0438\u043d\u0446\u0438\u043f \u043f\u043e\u0434\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0411\u0430\u0440\u0431\u0430\u0440\u044b \u041b\u0438\u0441\u043a\u043e\u0432 (Liskov Substitution Principle)&quot;,&quot;hid&quot;:&quot;\u043f\u0440\u0438\u043d\u0446\u0438\u043f_\u043f\u043e\u0434\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438_\u0431\u0430\u0440\u0431\u0430\u0440\u044b_\u043b\u0438\u0441\u043a\u043e\u0432_liskov_substitution_principle&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:4,&quot;range&quot;:&quot;1430-3820&quot;} -->
<h2 class="sectionedit5" id="принцип_разделения_интерфейса_interface_segregation_principle">Принцип разделения интерфейса (Interface Segregation Principle)</h2>
<div class="level2">

<p>
<code>Нельзя заставлять клиента реализовать интерфейс, которым он не пользуется.</code>
</p>

<p>
Это означает, что нужно разбивать интерфейсы на более мелкие, лучше удовлетворяющие конкретным потребностям клиентов.
</p>

<p>
Как и в случае с принципом единственной ответственности, цель принципа разделения интерфейса заключается в минимизации побочных эффектов и повторов за счёт разделения ПО на независимые части.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;\u041f\u0440\u0438\u043d\u0446\u0438\u043f \u0440\u0430\u0437\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430 (Interface Segregation Principle)&quot;,&quot;hid&quot;:&quot;\u043f\u0440\u0438\u043d\u0446\u0438\u043f_\u0440\u0430\u0437\u0434\u0435\u043b\u0435\u043d\u0438\u044f_\u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430_interface_segregation_principle&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:5,&quot;range&quot;:&quot;3821-4646&quot;} -->
<h2 class="sectionedit6" id="принцип_инверсии_зависимостей_dependency_inversion_principle">Принцип инверсии зависимостей (Dependency Inversion Principle)</h2>
<div class="level2">

<p>
<code>Высокоуровневые модули не должны зависеть от низкоуровневых. Оба вида модулей должны зависеть от абстракций.</code>
</p>

<p>
<code>Абстракции не должны зависеть от подробностей. Подробности должны зависеть от абстракций.</code>
</p>

<p>
Проще говоря: зависьте от абстракций, а не от чего-то конкретного.
</p>

<p>
Применяя этот принцип, одни модули можно легко заменять другими, всего лишь меняя модуль зависимости, и тогда никакие перемены в низкоуровневом модуле не повлияют на высокоуровневый.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;\u041f\u0440\u0438\u043d\u0446\u0438\u043f \u0438\u043d\u0432\u0435\u0440\u0441\u0438\u0438 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0435\u0439 (Dependency Inversion Principle)&quot;,&quot;hid&quot;:&quot;\u043f\u0440\u0438\u043d\u0446\u0438\u043f_\u0438\u043d\u0432\u0435\u0440\u0441\u0438\u0438_\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0435\u0439_dependency_inversion_principle&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:6,&quot;range&quot;:&quot;4647-5589&quot;} -->
<h2 class="sectionedit7" id="ссылки">Ссылки</h2>
<div class="level2">

<p>
<a href="https://habr.com/ru/company/mailru/blog/412699/" class="urlextern" target="_blank" title="https://habr.com/ru/company/mailru/blog/412699/" rel="ugc nofollow noopener">https://habr.com/ru/company/mailru/blog/412699/</a>
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;\u0421\u0441\u044b\u043b\u043a\u0438&quot;,&quot;hid&quot;:&quot;\u0441\u0441\u044b\u043b\u043a\u0438&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:7,&quot;range&quot;:&quot;5590-&quot;} -->