a:111:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:5:"SOLID";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:23;}i:4;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:104:"Принцип единственной ответственности (Single Responsibility Principle)";i:1;i:2;i:2;i:23;}i:2;i:23;}i:5;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:23;}i:6;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:23;}i:7;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:141;}i:8;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:111:"Существует лишь одна причина, приводящая к изменению класса.";}i:2;i:143;}i:9;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:254;}i:10;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:256;}i:11;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:256;}i:12;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:505:"Один класс должен решать только какую-то одну задачу. Он может иметь несколько методов, но они должны использоваться лишь для решения общей задачи. Все методы и свойства должны служить одной цели. Если класс имеет несколько назначений, его нужно разделить на отдельные классы.";}i:2;i:258;}i:13;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:763;}i:14;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:767;}i:15;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:80:"Принцип открытости/закрытости (Open-closed Principle)";i:1;i:2;i:2;i:767;}i:2;i:767;}i:16;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:767;}i:17;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:767;}i:18;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:861;}i:19;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:156:"Программные сущности должны быть открыты для расширения, но закрыты для модификации.";}i:2;i:863;}i:20;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:1019;}i:21;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1021;}i:22;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1021;}i:23;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:404:"Программные сущности (классы, модули, функции и прочее) должны быть расширяемыми без изменения своего содержимого. Если строго соблюдать этот принцип, то можно регулировать поведение кода без изменения самого исходника.";}i:2;i:1023;}i:24;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1427;}i:25;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1430;}i:26;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:97:"Принцип подстановки Барбары Лисков (Liskov Substitution Principle)";i:1;i:2;i:2;i:1430;}i:2;i:1430;}i:27;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1430;}i:28;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1430;}i:29;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:257:"Этот принцип Барбара Лисков предложила в своём докладе “Data abstraction” в 1987-м. А в 1994-м идея была вкратце сформулирована Барбарой и Дженнет Уинг:";}i:2;i:1541;}i:30;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1798;}i:31;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1798;}i:32;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:1800;}i:33;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:206:"Пусть φ(x) — доказуемое свойство объекта x типа T. Тогда φ(y) должно быть верным для объектов y типа S, где S — подтип T.";}i:2;i:1802;}i:34;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:2008;}i:35;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2010;}i:36;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2010;}i:37;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:234:"В удобочитаемой версии повторяется практически всё, что говорил Бертранд Майер, но здесь в качестве базиса взята система типов:";}i:2;i:2012;}i:38;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2247;}i:39;a:3:{i:0;s:10:"listo_open";i:1;a:0:{}i:2;i:2247;}i:40;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2247;}i:41;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2247;}i:42;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:105:" Предварительные условия не могут быть усилены в подтипе.";}i:2;i:2251;}i:43;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2356;}i:44;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2356;}i:45;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2356;}i:46;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2356;}i:47;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:86:" Постусловия не могут быть ослаблены в подтипе.";}i:2;i:2360;}i:48;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2446;}i:49;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2446;}i:50;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2446;}i:51;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2446;}i:52;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:98:" Инварианты супертипа могут быть сохранены в подтипе.";}i:2;i:2450;}i:53;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2548;}i:54;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2548;}i:55;a:3:{i:0;s:11:"listo_close";i:1;a:0:{}i:2;i:2548;}i:56;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2548;}i:57;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:109:"Роберт Мартин в 1996-м дал другое определение, более понятное:";}i:2;i:2551;}i:58;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2660;}i:59;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2660;}i:60;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:2662;}i:61;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:247:"Функции, использующие указатели ссылок на базовые классы, должны уметь использовать объекты производных классов, даже не зная об этом.";}i:2;i:2664;}i:62;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:2911;}i:63;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2913;}i:64;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2913;}i:65;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:191:"Попросту говоря: подкласс/производный класс должен быть взаимозаменяем с базовым/родительским классом.";}i:2;i:2915;}i:66;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3106;}i:67;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3106;}i:68;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:711:"Значит, любая реализация абстракции (интерфейса) должна быть взаимозаменяемой в любом месте, в котором принимается эта абстракция. По сути, когда мы используем в коде интерфейсы, то используем контракт не только по входным данным, принимаемым интерфейсом, но и по выходным данным, возвращаемым разными классами, реализующими этот интерфейс. В обоих случаях данные должны быть одного типа.";}i:2;i:3108;}i:69;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3819;}i:70;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3821;}i:71;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:90:"Принцип разделения интерфейса (Interface Segregation Principle)";i:1;i:2;i:2;i:3821;}i:2;i:3821;}i:72;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:3821;}i:73;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3821;}i:74;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:3925;}i:75;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:138:"Нельзя заставлять клиента реализовать интерфейс, которым он не пользуется.";}i:2;i:3927;}i:76;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:4065;}i:77;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4067;}i:78;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4067;}i:79;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:218:"Это означает, что нужно разбивать интерфейсы на более мелкие, лучше удовлетворяющие конкретным потребностям клиентов.";}i:2;i:4069;}i:80;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4287;}i:81;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4287;}i:82;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:355:"Как и в случае с принципом единственной ответственности, цель принципа разделения интерфейса заключается в минимизации побочных эффектов и повторов за счёт разделения ПО на независимые части.";}i:2;i:4289;}i:83;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4644;}i:84;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4647;}i:85;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:89:"Принцип инверсии зависимостей (Dependency Inversion Principle)";i:1;i:2;i:2;i:4647;}i:2;i:4647;}i:86;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:4647;}i:87;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4647;}i:88;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:4750;}i:89;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:201:"Высокоуровневые модули не должны зависеть от низкоуровневых. Оба вида модулей должны зависеть от абстракций.";}i:2;i:4752;}i:90;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:4953;}i:91;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4955;}i:92;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4955;}i:93;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:4957;}i:94;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:166:"Абстракции не должны зависеть от подробностей. Подробности должны зависеть от абстракций.";}i:2;i:4959;}i:95;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:5125;}i:96;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5127;}i:97;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5127;}i:98;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:119:"Проще говоря: зависьте от абстракций, а не от чего-то конкретного.";}i:2;i:5129;}i:99;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5248;}i:100;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5248;}i:101;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:336:"Применяя этот принцип, одни модули можно легко заменять другими, всего лишь меняя модуль зависимости, и тогда никакие перемены в низкоуровневом модуле не повлияют на высокоуровневый.";}i:2;i:5250;}i:102;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5586;}i:103;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5590;}i:104;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:12:"Ссылки";i:1;i:2;i:2;i:5590;}i:2;i:5590;}i:105;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:5590;}i:106;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5590;}i:107;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:47:"https://habr.com/ru/company/mailru/blog/412699/";i:1;N;}i:2;i:5616;}i:108;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5667;}i:109;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5668;}i:110;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:5668;}}