a:322:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:43:"15 полезных команд PostgreSQL";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:340:"В сети много руководств по PostgreSQL, которые описывают основные команды. Но при погружении глубже в работу возникают такие практические вопросы, для которых требуются продвинутые команды.";}i:2;i:61;}i:5;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:401;}i:6;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:401;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:297:"Такие команды, или сниппеты, редко описаны в документации. Рассмотрим несколько на примерах, полезных как для разработчиков, так и для администраторов баз данных.";}i:2;i:403;}i:8;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:700;}i:9;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:703;}i:10;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:64:"Получение информации о базе данных";i:1;i:2;i:2;i:703;}i:2;i:703;}i:11;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:703;}i:12;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:782;}i:13;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:34:"Размер базы данных";i:1;i:3;i:2;i:782;}i:2;i:782;}i:14;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:782;}i:15;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:782;}i:16;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:172:"Чтобы получить физический размер файлов (хранилища) базы данных, используем следующий запрос:";}i:2;i:829;}i:17;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1001;}i:18;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:46:"
SELECT pg_database_size(current_database());
";i:1;N;i:2;N;}i:2;i:1008;}i:19;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1008;}i:20;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:89:"Результат будет представлен как число вида 41809016.";}i:2;i:1064;}i:21;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1153;}i:22;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1153;}i:23;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:186:"current_database() — функция, которая возвращает имя текущей базы данных. Вместо неё можно ввести имя текстом:";}i:2;i:1155;}i:24;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1341;}i:25;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:41:"
SELECT pg_database_size('my_database');
";i:1;N;i:2;N;}i:2;i:1348;}i:26;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1348;}i:27;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:163:"Для того, чтобы получить информацию в человекочитаемом виде, используем функцию pg_size_pretty:";}i:2;i:1399;}i:28;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1562;}i:29;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:62:"
SELECT pg_size_pretty(pg_database_size(current_database()));
";i:1;N;i:2;N;}i:2;i:1569;}i:30;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1569;}i:31;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:75:"В результате получим информацию вида 40 Mb.";}i:2;i:1640;}i:32;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1715;}i:33;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1718;}i:34;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:29:"Перечень таблиц";i:1;i:3;i:2;i:1718;}i:2;i:1718;}i:35;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1718;}i:36;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1718;}i:37;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:173:"Иногда требуется получить перечень таблиц базы данных. Для этого используем следующий запрос:";}i:2;i:1760;}i:38;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1933;}i:39;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:113:"
SELECT table_name FROM information_schema.tables
WHERE table_schema NOT IN ('information_schema','pg_catalog');
";i:1;N;i:2;N;}i:2;i:1940;}i:40;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1940;}i:41;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:351:"information_schema — стандартная схема базы данных, которая содержит коллекции представлений (views), таких как таблицы, поля и т.д. Представления таблиц содержат информацию обо всех таблицах баз данных.";}i:2;i:2063;}i:42;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2414;}i:43;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2414;}i:44;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:152:"Запрос, описанный ниже, выберет все таблицы из указанной схемы текущей базы данных:";}i:2;i:2416;}i:45;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2568;}i:46;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:156:"
SELECT table_name FROM information_schema.tables
WHERE table_schema NOT IN ('information_schema', 'pg_catalog')
AND table_schema IN('public', 'myschema');
";i:1;N;i:2;N;}i:2;i:2575;}i:47;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2575;}i:48;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:109:"В последнем условии IN можно указать имя определенной схемы.";}i:2;i:2741;}i:49;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2850;}i:50;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2853;}i:51;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:27:"Размер таблицы";i:1;i:3;i:2;i:2853;}i:2;i:2853;}i:52;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2853;}i:53;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2853;}i:54;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:218:"По аналогии с получением размера базы данных размер данных таблицы можно вычислить с помощью соответствующей функции:";}i:2;i:2893;}i:55;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3111;}i:56;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:38:"
SELECT pg_relation_size('accounts');
";i:1;N;i:2;N;}i:2;i:3118;}i:57;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3118;}i:58;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:195:"Функция pg_relation_size возвращает объём, который занимает на диске указанный слой заданной таблицы или индекса.";}i:2;i:3166;}i:59;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3361;}i:60;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3364;}i:61;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:47:"Имя самой большой таблицы";i:1;i:3;i:2;i:3364;}i:2;i:3364;}i:62;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3364;}i:63;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3364;}i:64;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:223:"Для того, чтобы вывести список таблиц текущей базы данных, отсортированный по размеру таблицы, выполним следующий запрос:";}i:2;i:3423;}i:65;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3646;}i:66;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:64:"
SELECT relname, relpages FROM pg_class ORDER BY relpages DESC;
";i:1;N;i:2;N;}i:2;i:3653;}i:67;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3653;}i:68;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:165:"Для того, чтобы вывести информацию о самой большой таблице, ограничим запрос с помощью LIMIT:";}i:2;i:3727;}i:69;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3892;}i:70;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:72:"
SELECT relname, relpages FROM pg_class ORDER BY relpages DESC LIMIT 1;
";i:1;N;i:2;N;}i:2;i:3899;}i:71;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3899;}i:72;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:87:"relname — имя таблицы, индекса, представления и т.п.";}i:2;i:3981;}i:73;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4068;}i:74;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4068;}i:75;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:204:"relpages — размер представления этой таблицы на диске в количествах страниц (по умолчанию одна страницы равна 8 Кб).";}i:2;i:4070;}i:76;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4274;}i:77;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4274;}i:78;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:152:"pg_class — системная таблица, которая содержит информацию о связях таблиц базы данных.";}i:2;i:4276;}i:79;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4428;}i:80;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4430;}i:81;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:68:"Перечень подключенных пользователей";i:1;i:3;i:2;i:4430;}i:2;i:4430;}i:82;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4430;}i:83;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4430;}i:84;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:174:"Чтобы узнать имя, IP и используемый порт подключенных пользователей, выполним следующий запрос:";}i:2;i:4511;}i:85;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4685;}i:86;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:71:"
SELECT datname,usename,client_addr,client_port FROM pg_stat_activity;
";i:1;N;i:2;N;}i:2;i:4692;}i:87;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4773;}i:88;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:45:"Активность пользователя";i:1;i:3;i:2;i:4773;}i:2;i:4773;}i:89;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4773;}i:90;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4773;}i:91;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:168:"Чтобы узнать активность соединения конкретного пользователя, используем следующий запрос:";}i:2;i:4831;}i:92;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4999;}i:93;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:65:"
SELECT datname FROM pg_stat_activity WHERE usename = 'devuser';
";i:1;N;i:2;N;}i:2;i:5006;}i:94;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5081;}i:95;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:59:"Работа с данными и полями таблиц";i:1;i:2;i:2;i:5081;}i:2;i:5081;}i:96;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:5081;}i:97;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5155;}i:98;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:48:"Удаление одинаковых строк";i:1;i:3;i:2;i:5155;}i:2;i:5155;}i:99;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:5155;}i:100;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5155;}i:101;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:475:"Если так получилось, что в таблице нет первичного ключа (primary key), то наверняка среди записей найдутся дубликаты. Если для такой таблицы, особенно большого размера, необходимо поставить ограничения (constraint) для проверки целостности, то удалим следующие элементы:";}i:2;i:5216;}i:102;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5691;}i:103;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5691;}i:104;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:442:"дублирующиеся строки,
ситуации, когда одна или более колонок дублируются (если эти колонки предполагается использовать в качестве первичного ключа).
Рассмотрим таблицу с данными покупателей, где задублирована целая строка (вторая по счёту).";}i:2;i:5693;}i:105;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6135;}i:106;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6135;}i:107;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:15:":postgre_01.png";i:1;s:0:"";i:2;N;i:3;s:3:"600";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:6137;}i:108;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6161;}i:109;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6161;}i:110;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:88:"Удалить все дубликаты поможет следующий запрос:";}i:2;i:6163;}i:111;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6251;}i:112;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:97:"
DELETE FROM customers WHERE ctid NOT IN
(SELECT max(ctid) FROM customers GROUP BY customers.*);
";i:1;N;i:2;N;}i:2;i:6258;}i:113;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6258;}i:114;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:158:"Уникальное для каждой записи поле ctid по умолчанию скрыто, но оно есть в каждой таблице.";}i:2;i:6366;}i:115;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6524;}i:116;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6524;}i:117;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:195:"Последний запрос требователен к ресурсам, поэтому будьте аккуратны при его выполнении на рабочем проекте.";}i:2;i:6526;}i:118;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6721;}i:119;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6721;}i:120;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:110:"Теперь рассмотрим случай, когда повторяются значения полей.";}i:2;i:6724;}i:121;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6834;}i:122;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6834;}i:123;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:15:":postgre_02.png";i:1;s:0:"";i:2;N;i:3;s:3:"600";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:6836;}i:124;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6860;}i:125;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6860;}i:126;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:158:"Если допустимо удаление дубликатов без сохранения всех данных, выполним такой запрос:";}i:2;i:6862;}i:127;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7020;}i:128;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:97:"
DELETE FROM customers WHERE ctid NOT IN
(SELECT max(ctid) FROM customers GROUP BY customer_id);
";i:1;N;i:2;N;}i:2;i:7027;}i:129;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7027;}i:130;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:115:"Если данные важны, то сначала нужно найти записи с дубликатами:";}i:2;i:7134;}i:131;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7249;}i:132;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:99:"
SELECT * FROM customers WHERE ctid NOT IN
(SELECT max(ctid) FROM customers GROUP BY customer_id);
";i:1;N;i:2;N;}i:2;i:7256;}i:133;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7256;}i:134;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:15:":postgre_03.png";i:1;s:0:"";i:2;N;i:3;s:3:"600";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:7367;}i:135;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7391;}i:136;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7391;}i:137;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:204:"Перед удалением такие записи можно перенести во временную таблицу или заменить в них значение customer_id на другое.";}i:2;i:7394;}i:138;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7598;}i:139;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7598;}i:140;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:153:"Общая форма запроса на удаление описанных выше записей выглядит следующим образом:";}i:2;i:7600;}i:141;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7753;}i:142;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:109:"
DELETE FROM table_name WHERE ctid NOT IN (SELECT max(ctid) FROM table_name GROUP BY column1, [column 2,] );
";i:1;N;i:2;N;}i:2;i:7760;}i:143;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:7879;}i:144;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:57:"Безопасное изменение типа поля";i:1;i:3;i:2;i:7879;}i:2;i:7879;}i:145;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:7879;}i:146;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7879;}i:147;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:349:"Может возникнуть вопрос о включении в этот список такой задачи. Ведь в PostgreSQL изменить тип поля очень просто с помощью команды ALTER. Давайте для примера снова рассмотрим таблицу с покупателями.";}i:2;i:7949;}i:148;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8298;}i:149;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8298;}i:150;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:501:"Для поля customer_id используется строковый тип данных varchar. Это ошибка, так как в этом поле предполагается хранить идентификаторы покупателей, которые имеют целочисленный формат integer. Использование varchar неоправданно. Попробуем исправить это недоразумение с помощью команды ALTER:";}i:2;i:8300;}i:151;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8801;}i:152;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:62:"
ALTER TABLE customers ALTER COLUMN customer_id TYPE integer;
";i:1;N;i:2;N;}i:2;i:8808;}i:153;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8808;}i:154;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:78:"Но в результате выполнения получим ошибку:";}i:2;i:8880;}i:155;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8958;}i:156;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:155:"
ERROR: column “customer_id” cannot be cast automatically to type integer
SQL state: 42804
Hint: Specify a USING expression to perform the conversion.
";i:1;N;i:2;N;}i:2;i:8965;}i:157;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8965;}i:158;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:680:"Это значит, что нельзя просто так взять и изменить тип поля при наличии данных в таблице. Так как использовался тип varchar, СУБД не может определить принадлежность значения к integer. Хотя данные соответствуют именно этому типу. Для того, чтобы уточнить этот момент, в сообщении об ошибке предлагается использовать выражение USING, чтобы корректно преобразовать наши данные в integer:";}i:2;i:9130;}i:159;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9810;}i:160;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:91:"
ALTER TABLE customers ALTER COLUMN customer_id TYPE integer USING (customer_id::integer);
";i:1;N;i:2;N;}i:2;i:9817;}i:161;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9817;}i:162;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:64:"В результате всё прошло без ошибок:";}i:2;i:9918;}i:163;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9982;}i:164;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9982;}i:165;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:15:":postgre_04.png";i:1;s:0:"";i:2;N;i:3;s:3:"600";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:9984;}i:166;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10008;}i:167;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10008;}i:168;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:243:"Обратите внимание, что при использовании USING кроме конкретного выражения возможно использование функций, других полей и операторов.";}i:2;i:10010;}i:169;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10253;}i:170;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10253;}i:171;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:156:"Например, преобразуем поле customer_id обратно в varchar, но с преобразованием формата данных:";}i:2;i:10255;}i:172;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10411;}i:173;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:103:"
ALTER TABLE customers ALTER COLUMN customer_id TYPE varchar USING (customer_id || '-' || first_name);
";i:1;N;i:2;N;}i:2;i:10418;}i:174;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10418;}i:175;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:78:"В результате таблица примет следующий вид:";}i:2;i:10531;}i:176;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10609;}i:177;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10609;}i:178;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:15:":postgre_05.png";i:1;s:0:"";i:2;N;i:3;s:3:"600";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:10611;}i:179;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10635;}i:180;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:10637;}i:181;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:52:"Поиск «потерянных» значений";i:1;i:3;i:2;i:10637;}i:2;i:10637;}i:182;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:10637;}i:183;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10637;}i:184;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:585:"Будьте внимательны при использовании последовательностей (sequence) в качестве первичного ключа (primary key): при назначении некоторые элементы последовательности случайно пропускаются, в результате работы с таблицей некоторые записи удаляются. Такие значения можно использовать снова, но найти их в больших таблицах сложно.";}i:2;i:10702;}i:185;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11287;}i:186;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11287;}i:187;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:15:":postgre_06.png";i:1;s:0:"";i:2;N;i:3;s:3:"600";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:11289;}i:188;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11313;}i:189;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11313;}i:190;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:58:"Рассмотрим два варианта поиска.";}i:2;i:11315;}i:191;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11373;}i:192;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11373;}i:193;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:11375;}i:194;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:"Первый способ";}i:2;i:11377;}i:195;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:11402;}i:196;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11404;}i:197;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11404;}i:198;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:151:"Выполним следующий запрос, чтобы найти начало интервала с «потерянным» значением:";}i:2;i:11406;}i:199;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11557;}i:200;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:157:"
SELECT customer_id + 1
FROM customers mo
WHERE NOT EXISTS
(
SELECT NULL
FROM customers mi
WHERE mi.customer_id = mo.customer_id + 1
)
ORDER BY customer_id;
";i:1;N;i:2;N;}i:2;i:11564;}i:201;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11564;}i:202;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:68:"В результате получим значения: 5, 9 и 11.";}i:2;i:11731;}i:203;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11799;}i:204;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11799;}i:205;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:214:"Если нужно найти не только первое вхождение, а все пропущенные значения, используем следующий (ресурсоёмкий!) запрос:";}i:2;i:11801;}i:206;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12015;}i:207;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:240:"
WITH seq_max AS (
SELECT max(customer_id) FROM customers
),
seq_min AS (
SELECT min(customer_id) FROM customers
)
SELECT * FROM generate_series((SELECT min FROM seq_min),(SELECT max FROM seq_max))
EXCEPT
SELECT customer_id FROM customers;
";i:1;N;i:2;N;}i:2;i:12022;}i:208;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12022;}i:209;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:84:"В результате видим следующий результат: 5, 9 и 6.";}i:2;i:12272;}i:210;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12356;}i:211;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12356;}i:212;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:12358;}i:213;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:"Второй способ";}i:2;i:12360;}i:214;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:12385;}i:215;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12387;}i:216;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12387;}i:217;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:96:"Получаем имя последовательности, связанной с customer_id:";}i:2;i:12389;}i:218;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12485;}i:219;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:60:"
SELECT pg_get_serial_sequence('customers', 'customer_id');
";i:1;N;i:2;N;}i:2;i:12492;}i:220;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12492;}i:221;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:77:"И находим все пропущенные идентификаторы:";}i:2;i:12562;}i:222;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12639;}i:223;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:233:"
WITH sequence_info AS (
SELECT start_value, last_value FROM "SchemaName"."SequenceName"
)
SELECT generate_series ((sequence_info.start_value), (sequence_info.last_value))
FROM sequence_info
EXCEPT
SELECT customer_id FROM customers;
";i:1;N;i:2;N;}i:2;i:12646;}i:224;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:12890;}i:225;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:64:"Подсчёт количества строк в таблице";i:1;i:3;i:2;i:12890;}i:2;i:12890;}i:226;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:12890;}i:227;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12890;}i:228;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:201:"Количество строк вычисляется стандартной функцией count, но её можно использовать с дополнительными условиями.";}i:2;i:12967;}i:229;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13168;}i:230;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13168;}i:231;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:61:"Общее количество строк в таблице:";}i:2;i:13170;}i:232;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13231;}i:233;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:29:"
SELECT count(*) FROM table;
";i:1;N;i:2;N;}i:2;i:13238;}i:234;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13238;}i:235;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:117:"Количество строк при условии, что указанное поле не содержит NULL:";}i:2;i:13277;}i:236;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13394;}i:237;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:36:"
SELECT count(col_name) FROM table;
";i:1;N;i:2;N;}i:2;i:13401;}i:238;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13401;}i:239;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:88:"Количество уникальных строк по указанному полю:";}i:2;i:13447;}i:240;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13535;}i:241;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:45:"
SELECT count(distinct col_name) FROM table;
";i:1;N;i:2;N;}i:2;i:13542;}i:242;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:13597;}i:243;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:47:"Использование транзакций";i:1;i:3;i:2;i:13597;}i:2;i:13597;}i:244;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:13597;}i:245;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13597;}i:246;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:347:"Транзакция объединяет последовательность действий в одну операцию. Её особенность в том, что при ошибке в выполнении транзакции ни один из результатов действий не сохранится в базе данных.";}i:2;i:13657;}i:247;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14004;}i:248;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14004;}i:249;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:73:"Начнём транзакцию с помощью команды BEGIN.";}i:2;i:14006;}i:250;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14079;}i:251;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14079;}i:252;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:160:"Для того, чтобы откатить все операции, расположенные после BEGIN, используем команду ROLLBACK.";}i:2;i:14081;}i:253;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14241;}i:254;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14241;}i:255;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:59:"А чтобы применить — команду COMMIT.";}i:2;i:14243;}i:256;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14302;}i:257;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:14304;}i:258;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:80:"Просмотр и завершение исполняемых запросов";i:1;i:3;i:2;i:14304;}i:2;i:14304;}i:259;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:14304;}i:260;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14304;}i:261;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:138:"Для того, чтобы получить информацию о запросах, выполним следующую команду:";}i:2;i:14397;}i:262;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14535;}i:263;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:179:"
SELECT pid, age(query_start, clock_timestamp()), usename, query
FROM pg_stat_activity
WHERE query != '<IDLE>' AND query NOT ILIKE '%pg_stat_activity%'
ORDER BY query_start desc;
";i:1;N;i:2;N;}i:2;i:14542;}i:264;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14542;}i:265;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:184:"Для того, чтобы остановить конкретный запрос, выполним следующую команду, с указанием id процесса (pid):";}i:2;i:14731;}i:266;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14915;}i:267;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:36:"
SELECT pg_cancel_backend(procpid);
";i:1;N;i:2;N;}i:2;i:14922;}i:268;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14922;}i:269;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:95:"Для того, чтобы прекратить работу запроса, выполним:";}i:2;i:14968;}i:270;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15063;}i:271;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:39:"
SELECT pg_terminate_backend(procpid);
";i:1;N;i:2;N;}i:2;i:15070;}i:272;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:15120;}i:273;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:42:"Работа с конфигурацией";i:1;i:2;i:2;i:15120;}i:2;i:15120;}i:274;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:15120;}i:275;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:15176;}i:276;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:95:"Поиск и изменение расположения экземпляра кластера";i:1;i:3;i:2;i:15176;}i:2;i:15176;}i:277;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:15176;}i:278;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15176;}i:279;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:632:"Возможна ситуация, когда на одной операционной системе настроено несколько экземпляров PostgreSQL, которые «сидят» на различных портах. В этом случае поиск пути к физическому размещению каждого экземпляра — достаточно нервная задача. Для того, чтобы получить эту информацию, выполним следующий запрос для любой базы данных интересующего кластера:";}i:2;i:15283;}i:280;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15915;}i:281;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:22:"
SHOW data_directory;
";i:1;N;i:2;N;}i:2;i:15922;}i:282;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15922;}i:283;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:91:"Изменим расположение на другое с помощью команды:";}i:2;i:15954;}i:284;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16045;}i:285;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:43:"
SET data_directory to new_directory_path;
";i:1;N;i:2;N;}i:2;i:16052;}i:286;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16052;}i:287;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:126:"Но для того, чтобы изменения вступили в силу, требуется перезагрузка.";}i:2;i:16105;}i:288;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16231;}i:289;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:16233;}i:290;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:76:"Получение перечня доступных типов данных";i:1;i:3;i:2;i:16233;}i:2;i:16233;}i:291;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:16233;}i:292;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16233;}i:293;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:108:"Получим перечень доступных типов данных с помощью команды:";}i:2;i:16322;}i:294;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16430;}i:295;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:56:"
SELECT typname, typlen from pg_type where typtype='b';
";i:1;N;i:2;N;}i:2;i:16437;}i:296;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16437;}i:297;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:88:"typname — имя типа данных.
typlen — размер типа данных.";}i:2;i:16503;}i:298;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16591;}i:299;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:16594;}i:300;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:76:"Изменение настроек СУБД без перезагрузки";i:1;i:3;i:2;i:16594;}i:2;i:16594;}i:301;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:16594;}i:302;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16594;}i:303;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:792:"Настройки PostgreSQL находятся в специальных файлах вроде postgresql.conf и pg_hba.conf. После изменения этих файлов нужно, чтобы СУБД снова получила настройки. Для этого производится перезагрузка сервера баз данных. Понятно, что приходится это делать, но на продакшн-версии проекта, которым пользуются тысячи пользователей, это очень нежелательно. Поэтому в PostgreSQL есть функция, с помощью которой можно применить изменения без перезагрузки сервера:";}i:2;i:16683;}i:304;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17475;}i:305;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:26:"
SELECT pg_reload_conf();
";i:1;N;i:2;N;}i:2;i:17482;}i:306;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17482;}i:307;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:226:"Но, к сожалению, она применима не ко всем параметрам. В некоторых случаях для применения настроек перезагрузка обязательна.";}i:2;i:17518;}i:308;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17744;}i:309;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17744;}i:310;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:483:"Мы рассмотрели команды, которые помогут упростить работу разработчикам и администраторам баз данных, использующим PostgreSQL. Но это далеко не все возможные приёмы. Если вы сталкивались с интересными задачами, напишите о них в комментариях. Поделимся полезным опытом!";}i:2;i:17746;}i:311;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18229;}i:312;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:18231;}i:313;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:12:"Ссылки";i:1;i:2;i:2;i:18231;}i:2;i:18231;}i:314;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:18231;}i:315;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18231;}i:316;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:"Источник ";}i:2;i:18258;}i:317;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:59:"https://tproger.ru/translations/useful-postgresql-commands/";i:1;N;}i:2;i:18275;}i:318;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:0:"";}i:2;i:18338;}i:319;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18338;}i:320;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:18338;}i:321;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:18338;}}